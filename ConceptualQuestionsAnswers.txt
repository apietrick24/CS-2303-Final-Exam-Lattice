1) Why are sequence diagrams important and useful?

Sequence diagrams are useful as they document the complicated works of a system and visually show how the system's 
participants work together to produce some end result. By focusing on creating a sequence diagram, a programmer is 
thinking about the general structure of the entire system; bringing the system to its most abstract level. There, 
clusters of fields/functions that work together can be seen and the systems can be broken down into participants for 
smaller tasks. Sequence diagrams are also helpful while organizing the structure of the participants. For example, 
sequence diagrams show what fields/functions the other participants need to be able to access and what these other
participants are expecting when they call a function. In all, sequence diagrams give structure to the practice of 
programming and allow for easier communication between participants and even different programmers.  

2) How  is  it  that  using  test-driven  development  is  better  than  using  the debugger?

By using test-driven development, programmers can focus on the requirements of functions and classes before even 
writing the code. This allows them time to think about the fields/functions of a class and how it all comes together. 
Because of this slower approach to writing code, sometimes a programmer will realize that they don't actually need 
a function or class, saving them time and energy. Test-driven development also gives structure to the process of
debugging. By having multiple smaller tests designed to focus on individual chunks of the code, it reduces the scope
of possible bugs, allowing the programmer to knew actually where their code is breaking. Finally, test-driven development
focusing the programmer to think modular with the class and functions they write, producing better code that is less 
reliant on other classes.
   
3) How is it that thinking about test cases helps with the implementation of the function being tested?

By thinking about test cases first, a programmer can go into writing the actual function with a complete idea of its 
overall structure and return values for their implementation. Thinking about tests cases first allows the programmer 
to consider niche edge cases which, if they were to have just coded first, could have caused a lot of trouble debugging. 
In short, thinking about the test case first makes the implementation cleaner, more structured, and accurate to what the 
programmer had in mind. 

4) What is the purpose of using divide and conquer at the level of a function?

Using the idea of dividing and conquering allows for the function to be broken down into smaller parts. Each of these 
parts can then be solved and combined together to form the larger function. Dividing and conquering forces the programmer
to think only about a specific section of the function and how to correctly implement it. It removes the distractions of 
the rest of the function's complicated structural code, allowing the programmer to get as close to the actual problem as 
possible. Once the programmer has a solution for the subproblem, they then can merge it together with the other subproblems 
to complete the function. 

5) What does “traversing levels of abstraction” mean?  Give an example.

Traversing levels of abstraction means going from some conceptual problem and theoretical solution and to a more specific 
problem and a concrete solution. It's the process of taking some general tasks and developing a precise solution for them.  

For example, let's look at traversing levels of abstraction for getting a computer to understand a human sentence (NLP/NLU 
applications).  One higher level of abstract for this problem would be something along the lines of "getting the computer to 
read the sentence". Another level in the same problem could be "getting the computer to parse the sentence and then reference
dictionaries and grammar rules to understand it syntactically."  This level would be lower than the previous example as it deals
more with the actual parts of the desired solution. Another level lower than the previous example would be something like, "Get
the computer to parse the sentence by parts of speech, then find the subject, verb, and object".

Higher levels of abstraction are important as they give a good idea of how a systems work as a whole. These are useful when someone
wants to use the system as a function in something else and doesn't care too much about how it's implement and works.

Lower levels of abstraction give more detailed descriptions of functionalities and parts of the system. This is helpful for exploration
and discovery based on previously constructed systems. Lower levels of abstraction lead to interesting questions about the system's
behavior on certain inputs. 
